/*
  ____                                   _             _       
 / ___|  ___  _   _ _ __ ___ ___   _ __ | |_   _  __ _(_)_ __  
 \___ \ / _ \| | | | '__/ __/ _ \ | '_ \| | | | |/ _` | | '_ \ 
  ___) | (_) | |_| | | | (_|  __/ | |_) | | |_| | (_| | | | | |
 |____/ \___/ \__,_|_|  \___\___| | .__/|_|\__,_|\__, |_|_| |_|
                                  |_|            |___/         
# A Template for SourcePlugin, a Source Plugin
# Generated by the command: plugin source -d replay_plugin replay
# Hostname: Fram-IV.local
# Current working directory: /Users/p4010/Develop/MADS_plugins
# Creation date: 2025-09-05T16:04:08.433+0200
# NOTICE: MADS Version 1.3.5
*/
// Mandatory included headers
#include <source.hpp>
#include <nlohmann/json.hpp>
#include <pugg/Kernel.h>
#include <replay.hpp>

// other includes as needed here
#include <thread>
#include <chrono>
#include <iostream>
// Define the name of the plugin
#ifndef PLUGIN_NAME
#define PLUGIN_NAME "source"
#endif

// Load the namespaces
using namespace std;
using json = nlohmann::json;


// Plugin class. This shall be the only part that needs to be modified,
// implementing the actual functionality
class SourcePlugin : public Source<json> {

public:

  // Typically, no need to change this
  string kind() override { return PLUGIN_NAME; }

  // Implement the actual functionality here
  return_type get_output(json &out,
                         std::vector<unsigned char> *blob = nullptr) override {
                        
    out = json::object();
    try {    

      if (!_replay->has_next()) {
          if(_params.value("loop", false)){
            _replay->reset();
            _first_packet  = true;
          }else{
            return return_type::critical;
          }
      }

      
        json raw_data = _replay->advance();
        
        // if out is null, empty or not object, skip
        if(raw_data.is_null() || raw_data.empty() || !raw_data.is_object()) return return_type::success;

        out = raw_data;

        double current_sim_time = 0.0;
        bool time_found = false;

        json flat = out.flatten();

        //Search for "/message/timecode"

        if (flat.contains("/message/timecode") && flat["/message/timecode"].is_number()){
            current_sim_time = flat["/message/timecode"].get<double>();
            time_found = true;
        }
        // search for "timecode"
        //else if (flat.contains("/timecode") && flat["/timecode"].is_number()) {
        //    current_sim_time = flat["/timecode"].get<double>();
        //    time_found = true;
        //}

        // time synchronization

        if(time_found){
          if (_first_packet){
            _initial_sim_time = current_sim_time;
            _start_real_time = std::chrono::steady_clock::now();
            _first_packet = false;
          } else {
            double dt_sim = current_sim_time - _initial_sim_time;
            auto dt_duration = std::chrono::microseconds(static_cast<long long>(dt_sim * 1e6));
            auto target_time = _start_real_time + dt_duration;
            
            // Sleep until target time
            std::this_thread::sleep_until(target_time);
            }
          }

          if(!_agent_id.empty()) out["agent_id"] = _agent_id;

          if(out.contains("timestamp")){
            _error = "timestamp field name is not allowed, it will be removed";
            out.erase("timestamp");
            return return_type::warning;
          }

    } catch (const std::exception &e) {
      // if something happens log error
      std::cerr << "[SourcePlugin] Error: " << e.what() << std::endl;
      out = json::object(); // reset output to empty JSON object
      // skip packet and continue
      return return_type::success;
    }

    return return_type::success;
  }

  void set_params(void const *params) override {
    // Call the parent class method to set the common parameters 
    // (e.g. agent_id, etc.)
    Source::set_params(params);

    // provide sensible defaults for the parameters by setting e.g.
    _params["loop"] = false;
    _params.merge_patch(*(json *)params);

    _replay = make_unique<Replay>(_params["csv_file"]);
    _replay->set_loop(_params["loop"]);
    _replay->reset();

    //Reset temp variables
    _first_packet = true;
    _initial_sim_time = 0.0;
  }
  
  
  
  	

  // Implement this method if you want to provide additional information
  map<string, string> info() override { 
    // return a map of strings with additional information about the plugin
    // it is used to print the information about the plugin when it is loaded
    // by the agent
    
    return {
      {"CSV file", _params["csv_file"]},
      {"Mode", "Safe Replay + Absolute Timing"}
    };
    
  };

private:
  unique_ptr<Replay> _replay; // alternative using unique_ptr

  double _initial_sim_time = 0.0; // timestamp last msg
  std::chrono::steady_clock::time_point _start_real_time; // Real time last msg
  bool _first_packet = true;
};


/*
  ____  _             _             _      _
 |  _ \| |_   _  __ _(_)_ __     __| |_ __(_)_   _____ _ __
 | |_) | | | | |/ _` | | '_ \   / _` | '__| \ \ / / _ \ '__|
 |  __/| | |_| | (_| | | | | | | (_| | |  | |\ V /  __/ |
 |_|   |_|\__,_|\__, |_|_| |_|  \__,_|_|  |_| \_/ \___|_|
                |___/
Enable the class as plugin
*/
INSTALL_SOURCE_DRIVER(SourcePlugin, json)


/*
                  _
  _ __ ___   __ _(_)_ __
 | '_ ` _ \ / _` | | '_ \
 | | | | | | (_| | | | | |
 |_| |_| |_|\__,_|_|_| |_|

For testing purposes, when directly executing the plugin
*/
int main(int argc, char const *argv[]) {
  SourcePlugin plugin;
  json output, params;

  // Set example values to params
  params["csv_file"] = "example.csv";
  params["loop"] = false;

  // Set the parameters
  plugin.set_params(&params);

  // Process data
  while (plugin.get_output(output) != return_type::critical) {
    // Produce output
    cout << "Output: " << output << endl;
  }
  return 0;
}
