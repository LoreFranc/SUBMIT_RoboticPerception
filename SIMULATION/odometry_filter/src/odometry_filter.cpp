/*
  _____ _ _ _                    _             _       
 |  ___(_) | |_ ___ _ __   _ __ | |_   _  __ _(_)_ __  
 | |_  | | | __/ _ \ '__| | '_ \| | | | |/ _` | | '_ \ 
 |  _| | | | ||  __/ |    | |_) | | |_| | (_| | | | | |
 |_|   |_|_|\__\___|_|    | .__/|_|\__,_|\__, |_|_| |_|
                          |_|            |___/         
# A Template for Odometry_filterPlugin, a Filter Plugin
# Generated by the command: plugin --type filter -d odometry_filter odometry_filter
# Hostname: lorenzo-XPS-13-7390
# Current working directory: /home/lorenzo/Documents/RoboticPerception
# Creation date: 2025-11-21T11:56:48.400+0100
# NOTICE: MADS Version 1.4.0
*/
/*
# FINAL EKF: WEIGHTED SENSOR FUSION
# Approach:
# 1. Calculate Position and Rotation from Encoders (High drift on turns, slipping issues...)
# 2. Calculate Rotation from Gyro (Drift over time, precise on turns)
# 3. Correction of slipping based on both pure acceleration and turning rate
# 4. Prediction of position and update of covariance matrix
# 5. Update of Kalman filter based on Aruco for absolute Position Correction
*/
// Mandatory included headers
#include <filter.hpp> 
#include <nlohmann/json.hpp>
#include <pugg/Kernel.h>

// other includes as needed here
#include <cmath>
#include <iostream>
#include <map>
#include <vector> 
#include <deque>
#include <numeric>
#include <Eigen/Dense>
// Define the name of the plugin
#ifndef PLUGIN_NAME
#define PLUGIN_NAME "odometry_filter"
#endif

// Load the namespaces
using namespace Eigen;
using namespace std;
using json = nlohmann::json;


//MAth consts
#ifndef M_PI
#define M_PI 3.14159265358979323846
#endif


class MovingAverage {
    std::deque<double> _window;
    size_t _size;
    double _sum = 0.0;
public:
    MovingAverage(size_t size = 10) : _size(size), _sum(0.0) {}
    
    void resize(size_t new_size) { _size = new_size; _window.clear(); _sum = 0.0; }

    void clear() { _window.clear(); _sum = 0.0; }

    double update(double val) {
        _window.push_back(val);
        _sum += val;
        if (_window.size() > _size){
          double removed = _window.front();
          _sum -= removed;
          _window.pop_front();
        } 

        if(_window.empty()) return 0.0;
        return _sum / _window.size();
    }

    double current_value() const {
        if(_window.empty()) return 0.0;
        return _sum / _window.size();
    }
};


// Plugin class. This shall be the only part that needs to be modified,
// implementing the actual functionality
class Odometry_filterPlugin : public Filter<json, json> {

  // Stato con eigen
  struct State{
    Vector3d x; // Stato: [x, y, theta]
    Matrix3d P; // Covarianza 3x3 
  };

    State _state;
    State _state_partial; // EKF parziale (Solo encoder + RS)

    struct StateRaw{
        double x = 0.0;
        double y = 0.0;
        double theta = 0.0;
    } _state_enc_only;

    struct DebugState {
        double theta_enc_only = 0.0;
        double theta_imu_only = 0.0;
    } _debug;

    struct DebugSlip {
        double enc_accel = 0.0;
        double imu_accel = 0.0;
        double enc_vel = 0.0;
        double imu_vel = 0.0;
        bool is_slipping = false; 

        double angle_diff = 0.0;
        double angle_ratio = 1.0;
        double accel_ratio = 1.0;
        double d_theta_enc = 0.0;
        double d_theta_imu = 0.0;

        double ds = 0.0;
        double ds_angle = 0.0;
        double ds_accel = 0.0;
        double ds_final = 0.0;
    } _debug_slip;

    struct DebugAngle{
      double angle_enc = 0.0;
      double angle_imu = 0.0;
      double avg_imu_enc = 0.0;
    } _debug_angle;

//MOST VALUES ARE DECLARED HERE, BUT SOME ARE REDEFINED IN THE MADS.INI FILE
    // Parametri Cinematici (Calibrati)
    struct Params {
        double wheel_radius_left = 0.0873;  // RL [m] 
        double wheel_radius_right = 0.0857; // RR [m]
        double baseline = 0.8291;          // B [m] 
        double ticks_per_rev = 4096;     // Risoluzione Encoder

        // kalman tuning
        double sigma_v = 0.05;  // vel uncertainty encoder
        double sigma_w = 0.05; // gyro uncertainty
        double sigma_rs_pos = 0.05;  // RealSense uncertainty
        double sigma_rs_ang = 0.05;  // RealSense angle uncertainty
        double sigma_acc = 0.065; // accelerometer uncertainty
        //double sigma_enc_lin = 0.05; // Errore encoder lineare (m/s)
        double sigma_enc_rot = 0.2;  // Errore encoder rotazionale (rad/s)
        double sigma_gyro = 0.002; // Errore giroscopio (rad/s)

        //double slip_accel_thresh = 0.5; // Soglia accelerazione per slip
        double min_imu_accel_for_correction = 0.001;    // Soglia per considerare fermo
        bool enable_slip_check = false;
        double alpha_a = 0.15;
        double alpha_v = 0.10;

        int filter_window_imu = 10;  
        int filter_window_enc = 10; // Finestra per accelerometro    

        double rs_global_rotation = 0.0;
        double cam_offset_x = 0.0;
        double cam_offset_y = 0.0;

        bool aruco_is_walker_center; //param to know if aruco is at walker center or camera center

        // Parametri Offset IMU (Lever Arm) nel frame del Robot
        double imu_offset_x = 0.70;
        double imu_offset_y = 0.20;
        double imu_offset_z = 0.00;

        bool calibration_active = false;
        double gyro_scaling = 1.005964613;//1798.690728/1788.025845; // scaling factor from calibration

        bool htc = false; // if true, use htc for error estimation
        
    } _conf;

    // BUffer data:
    long _incoming_ticks_l = 0;
    long _incoming_ticks_r = 0;

    // Encoder memory
    long _prev_ticks_l = 0;
    long _prev_ticks_r = 0;
    bool _initialized = false;
    bool _has_new_encoder_data = false;
    double _prev_ds = 0.0;

    // Moving Average Filters
    MovingAverage _filter_enc_a; // filtro ibrido per accelerazione encoder
    MovingAverage _filter_enc_theta; // filtro per velocità angolare encoder

    string _last_agent_id = "";
    double _last_timecode = 0.0;
    double _prev_time = 0.0;
    double _last_timecode_enc = 0.0;

    // IMU Data
    MovingAverage _filter_gyro;
    MovingAverage _filter_accel; 
    double _current_gyro_z = 0.0;
    double _current_accel_x = 0.0;

    double _bias_accel_x = 0.0;
    double _bias_gyro_z = 0.0;
    int _calibration_samples = 0;
    bool _bias_computed = false;
    const int CALIBRATION_LIMIT = 400;
    
    double _imu_accel_smooth_ema1 = 0.0;
    double _imu_accel_smooth_ema2 = 0.0;

    

    // Mem per calcolare derivata angolare
    double _prev_gyro_x = 0.0;
    double _prev_gyro_y = 0.0;
    double _prev_gyro_z = 0.0;
    double _prev_imu_timecode = 0.0;
    bool _first_imu_frame = true;

    double _v_enc_smooth = 0.0;
    double _a_enc_smooth = 0.0;
    double _prev_v_enc = 0.0; 

    // Memory for anti-freeze check
    double _prev_raw_rs_x = -9999.0;
    double _prev_raw_rs_y = -9999.0;
    double _ekf_theta_rs = 0.0;
    double raw_rs_x = 0.0, raw_rs_y = 0.0, raw_rs_theta = 0.0;

    // Correction data RealSense
    double _rs_x = 0.0;
    double _rs_y = 0.0;
    double _rs_theta = 0.0;
    bool _has_rs_update = false;

    // Variabili interne per debug e calcolo velocità
    double _prev_input_rs_theta = 0.0; 

    //htc position
    double _htc_x = 0.0;
    double _htc_y = 0.0;
    double _htc_angle = 0.0;
    double _prev_htc_angle = 0.0;
    bool jump = false;
    double diff = 0.0;

    bool htc_data = false;

    std::vector<double> _calib_acc_x;
    std::vector<double> _calib_acc_y;
    std::vector<double> _calib_gyro_z;
    std::vector<double> _calib_rs_x;
    std::vector<double> _calib_rs_y;
    std::vector<double> _calib_rs_theta;


    // Error estimation from real value
    double _sum_err_dist_sq = 0.0;
    double _sum_err_theta_sq = 0.0;
    double _sum_err_dist = 0.0;
    double _sum_err_theta = 0.0;
    long _samples = 0;
    double err_dist = 0.0;
    double err_theta = 0.0;
    double rmse_dist = 0.0;
    double rmse_theta = 0.0;
    double std_dist = 0.0;


   

public:

  // Typically, no need to change this
  string kind() override { return PLUGIN_NAME; }

  map<string, string> info() override {
        return {
            {"type", "EKF + Raw Encoder + anti-slip logic + ARUCO"},
        };
  }

  Odometry_filterPlugin() : 
    _filter_gyro(_conf.filter_window_imu), 
    _filter_accel(_conf.filter_window_imu),
    _filter_enc_a(_conf.filter_window_enc),
    _filter_enc_theta(_conf.filter_window_enc)
    {}
  
  // -- Funzione di predizione EKF
void ekf_predict(State &s, double ds, double d_theta, double sigma_ds, double sigma_dth) {
  double theta = s.x(2);
  double cos_th = cos(theta + d_theta/2.0); // Half-angle approx per Runge-Kutta
  double sin_th = sin(theta + d_theta/2.0);

  // Predizione Stato
  s.x(0) += ds * cos_th;
  s.x(1) += ds * sin_th;
  s.x(2) += d_theta;
  s.x(2) = normalize_angle(s.x(2));

  // Jacobiano F (3x3)
  Matrix3d F = Matrix3d::Identity();
  F(0, 2) = -ds * sin_th;
  F(1, 2) =  ds * cos_th;
  
  // Matrice Rumore di Processo Q
  Matrix3d Q = Matrix3d::Zero();
  double var_ds = sigma_ds * sigma_ds;
  double var_dth = sigma_dth * sigma_dth;

  // Proiezione rumore
  Q(0, 0) = var_ds * cos_th * cos_th + 1e-9;
  Q(1, 1) = var_ds * sin_th * sin_th + 1e-9;
  Q(2, 2) = var_dth + 1e-9;

  // PREDIZIONE COVARIANZA: P = F * P * F^T + Q
  s.P = (F * s.P * F.transpose()) + Q; // update della matrice di covarianza

}  

// calculate std deviation
  double std_dev(const std::vector<double>& data) {
    if ( data.size() < 2) return 0.0;
    double sum = 0.0, mean, standardDeviation = 0.0;
    for (double num : data) sum += num;
    mean = sum / data.size();
    for(double num : data) standardDeviation += pow(num - mean, 2);
    return sqrt(standardDeviation / data.size());
  }

  // Normalizzazione angoli
double normalize_angle(double angle) {
    while (angle > M_PI) angle -= 2.0 * M_PI;
    while (angle < -M_PI) angle += 2.0 * M_PI;
    return angle;
}

// --- FUNZIONE DI CORREZIONE EKF (UPDATE) ---
void ekf_update(State &s, const Vector3d &z, const Matrix3d &R) {
  // Z = Misura [x, y, theta]
  // R Covarianza Misura

  Vector3d y = z - s.x; //differenza posizione e angolo tra predizione e aggiornamento
  y(2) = normalize_angle(y(2));

  Matrix3d H = Matrix3d::Identity();
  Matrix3d S = H * s.P * H.transpose() + R;
  Matrix3d K = s.P * H.transpose() * S.inverse(); // Guadagno di Kalman

  s.x = s.x + K * y; // aggiornamento stato in base al kalman gain
  s.x(2) = normalize_angle(s.x(2));

  Matrix3d I = Matrix3d::Identity();
  s.P = (I - K * H) * s.P; // aggiornamento covarianza
}
  // into the output json object
 return_type load_data(const json &in, std::string topic = "") override {
  try {

    // Timecode
    if(in["message"].contains("timecode")){
        _last_timecode = in["message"]["timecode"].get<double>();
    } 

    // Encoders
    if (in["agent_id"].get<string>() == "encoders_source") {
        
            _incoming_ticks_l = (long)in["message"]["encoders"]["left"].get<double>();
            _incoming_ticks_r = (long)in["message"]["encoders"]["right"].get<double>();
        

        if (!_initialized) {
            _prev_ticks_l = _incoming_ticks_l;
            _prev_ticks_r = _incoming_ticks_r;
            _prev_time = _last_timecode;
            _last_timecode_enc = _last_timecode;
            _initialized = true;
        } else {
            _has_new_encoder_data = true;
            _last_timecode_enc = _last_timecode;
        }
    }

    // HTC
    // il segnale presenta dei salti improvvisi di pi, correggo qui per ottenere una valutazione migliore dell'errore angolare (non sono riuscito a risolvere completamente quindi lo commento)
    if(in["agent_id"].get<string>() == "pose_htc_source") {
        try{
          if(in["message"]["pose"].contains("position")){
            auto& pos = in["message"]["pose"]["position"];

            if(pos.is_array() && pos.size() >= 2){

              _htc_x = pos[0].get<double>();
              _htc_y = pos[1].get<double>();
            }

            _htc_angle = in["message"]["pose"]["attitude"][2].get<double>();

            /*
            if(abs(_htc_angle - _prev_htc_angle) <= (M_PI + 0.1) && abs(_htc_angle - _prev_htc_angle) >= (M_PI - 0.1) ){
              diff = _htc_angle - _prev_htc_angle;
              _htc_angle = _htc_angle - diff;
              if (jump == false) jump = true;
              else if(jump == true) jump = false;
            } else if(jump == true){ 
              _htc_angle = _htc_angle - diff;
            }

            _prev_htc_angle = _htc_angle;
            */

            htc_data = true;
          }
        } catch(...){
        }
    }  
    
    // --- 3. IMU
    if (in["agent_id"].get<string>() == "imu_source") {
      //Variabili temporanee
      double gx_body = 0.0, gy_body = 0.0, gz_body = 0.0;
      double ax_body = 0.0, ay_body = 0.0, az_body = 0.0;
      
      //Gyro
        auto& gyro = in["message"]["gyro"];
          double raw_gx = gyro[0].get<double>();
          double raw_gy = gyro[1].get<double>();
          double raw_gz = gyro[2].get<double>();
          
          // Applicazione matrice di rotazione
          gx_body = raw_gy;
          gy_body = raw_gx;
          gz_body = -raw_gz;

      // Accel
        auto& accel = in["message"]["accel"];
          double raw_ay = accel[1].get<double>() * 9.80665;

          // Applicazione matrice di rotazione
          ax_body = raw_ay;
      
      // Process IMU Data if both gyro and accel are ready

        double dt_imu = _last_timecode - _prev_imu_timecode;
        if(dt_imu <= 0.0) dt_imu = 1e-6; // Prevenzione divisione per zero

        if(!_first_imu_frame){
          // Calcolo Accelerazione Angolare (Alpha = dOmega/dt)
          double alpha_x = (gx_body - _prev_gyro_x) / dt_imu;
          double alpha_y = (gy_body - _prev_gyro_y) / dt_imu;

          // Vettore Offset (lever arm)
          double rx = _conf.imu_offset_x;
          double ry = _conf.imu_offset_y;
          double rz = _conf.imu_offset_z;

          // Termine tangenziale (Alpha x R)
          double tan_x = alpha_y * rz - gz_body * ry;

          // Termine centripeto (Omega x (Omega x R))
          // Omega x R
          double oxr_y = gz_body * rx - gx_body * rz;
          double oxr_z = gx_body * ry - gy_body * rx;
          // Omega x (Omega x R)
          double cent_x = gy_body * oxr_z - gz_body * oxr_y;
        
          // Correzione finale
          double ax_corrected = ax_body - tan_x - cent_x;
          

          // Accelerometro X
          if(!_bias_computed){
            if(_calibration_samples < CALIBRATION_LIMIT){
              _bias_accel_x += ax_corrected;
              _bias_gyro_z += gz_body;
              _calibration_samples++;
              _current_accel_x = 0.0;
            } else {
              _bias_accel_x /= (double)CALIBRATION_LIMIT;
              _bias_gyro_z /= (double)CALIBRATION_LIMIT;
              _bias_computed = true;
              std::cout << "IMU Calibrated with lever arm. Bias acc_X: " << _bias_accel_x << " Bias gyro_Z: " << _bias_gyro_z << std::endl;
            }
          } else {
            _current_accel_x = ax_corrected - _bias_accel_x;
            _current_gyro_z = (gz_body - _bias_gyro_z)* _conf.gyro_scaling;

            
        }


      }
      // aggiorna storico per la derivata
        _prev_gyro_x = gx_body;
        _prev_gyro_y = gy_body;
        _prev_gyro_z = gz_body;
        _prev_imu_timecode = _last_timecode;
        _first_imu_frame = false;
      }   
    

    // RealSense
    if (in["agent_id"].get<string>() == "pose_rs_source") {
      
      auto& p = in["message"]["pose"];
        // Position
        if (p["position"][0].is_array()) {
          raw_rs_x = p["position"][0][0].get<double>();
          raw_rs_y = p["position"][0][1].get<double>();
        } else { // Capisci quale usi. AGGIORNAMENTO: CI SONO DUE FORMATI PERCHÈ I DATI NUOVI LI HANNO REGISTRATI IN UN SETUP LEGGERMENTE DIVERSO
          raw_rs_x = p["position"][0].get<double>();
          raw_rs_y = p["position"][1].get<double>();
        }

        // Angle (Handle nested arrays)
      if(p["attitude"][0].is_array()){
        raw_rs_theta = p["attitude"][0][2].get<double>();
      } else { // Capisci quale usi
        raw_rs_theta = p["attitude"][2].get<double>();
      }
 

      double delta_input = raw_rs_theta - _last_input_rs_theta;

      _last_input_rs_theta = raw_rs_theta;

      if(abs(delta_input) < 1e-6){ // semplicemente salta il dato se uguale al precedente o salta
        // do nothing
      } else {

      // Dataset logic
          if(_conf.aruco_is_walker_center){
            _rs_x = raw_rs_x;
            _rs_y = raw_rs_y;
            _rs_theta = normalize_angle(raw_rs_theta);
            _ekf_theta_rs = _rs_theta;
            
            
          }else{
            _rs_theta = normalize_angle(raw_rs_theta + _conf.rs_global_rotation);

            _rs_x = raw_rs_x * cos(_conf.rs_global_rotation) - raw_rs_y * sin(_conf.rs_global_rotation);
            _rs_y = raw_rs_x * sin(_conf.rs_global_rotation) + raw_rs_y * cos(_conf.rs_global_rotation);
          
            _rs_x = _rs_x + (cos(_rs_theta) * _conf.cam_offset_x - sin(_rs_theta) * _conf.cam_offset_y) + _conf.cam_offset_x;
            _rs_y = _rs_y + (sin(_rs_theta) * _conf.cam_offset_x + cos(_rs_theta) * _conf.cam_offset_y) + _conf.cam_offset_y;

            _ekf_theta_rs = normalize_angle(raw_rs_theta);
          }

      
      _has_rs_update = true;
      }
    }

    // This next section is only used for the calibration with the uncertainty dataset
    if(_conf.calibration_active == true){

      
        // Accumulate IMU data for calibration
        if(in["agent_id"].get<string>() == "imu_source") {
        _calib_acc_x.push_back(in["message"]["accel"][1].get<double>() * 9.80665);
        _calib_acc_y.push_back(in["message"]["accel"][0].get<double>() * 9.80665);
        _calib_gyro_z.push_back(in["message"]["gyro"][2].get<double>());
        }

        if(in["agent_id"].get<string>() == "pose_rs_source") {
          _calib_rs_x.push_back(in["message"]["pose"]["position"][0].get<double>());
          _calib_rs_y.push_back(in["message"]["pose"]["position"][1].get<double>());
          _calib_rs_theta.push_back(in["message"]["pose"]["attitude"][2].get<double>());
        }

        if(_calib_acc_x.size() > 0 && _calib_acc_x.size() % 500 == 0){
          double sig_ax = std_dev(_calib_acc_x);
          double sig_ay = std_dev(_calib_acc_y);
          double sig_gz = std_dev(_calib_gyro_z);
          double sig_rsx = std_dev(_calib_rs_x);
          double sig_rsy = std_dev(_calib_rs_y);
          double sig_rstheta = std_dev(_calib_rs_theta);

          std::cout << "---- Calibration Status ----" << std::endl;
          std::cout << "sigma_acc (Media X/Y) " << (sig_ax + sig_ay) / 2.0 << "(consigliato dinamico * 3)" << std::endl;
          std::cout << "Sigma gyro: " << sig_gz << "(Consigliato dinamico * 2)" << std::endl;
          std::cout << "sigma_rsx (Pos): " << sig_rsx << " m" << std::endl;
          std::cout << "sigma_rsy (Pos): " << sig_rsy << " m" << std::endl;
          std::cout << "sigma_rstheta (Pos): " << sig_rstheta << " rad" << std::endl;
          std::cout << "--------------------------------------" << std::endl;

          //_calib_acc_x.clear();
          //_calib_acc_y.clear();
          //_calib_gyro_z.clear();
          //_calib_rs_x.clear();
          //_calib_rs_y.clear();
          //_calib_rs_theta.clear();
        }

    }
  

    if (in.contains("agent_id")) _last_agent_id = in["agent_id"].get<string>();

  } catch (...){ return return_type::error; }
    return return_type::success;
  }
    


  // EKF Process
    return_type process(json &out) override {
        out.clear();

        // if no new data, skip
        if (!_has_new_encoder_data) { //this all gets updated ONLY if we have new encoder data
            return return_type::success; // O warning,
        }

        double current_dt = _last_timecode_enc - _prev_time;
        if(current_dt <= 0.01) return return_type::success; // Evita calcoli inutili

        long d_ticks_l = _incoming_ticks_l - _prev_ticks_l;
        long d_ticks_r = _incoming_ticks_r - _prev_ticks_r;
        _prev_ticks_l = _incoming_ticks_l;
        _prev_ticks_r = _incoming_ticks_r;
        _has_new_encoder_data = false;

        double dt = current_dt;
        _prev_time = _last_timecode_enc;

        // --- PREDICTION ---
        double d_left = (d_ticks_l / _conf.ticks_per_rev) * 2.0 * M_PI * _conf.wheel_radius_left;
        double d_right = (d_ticks_r / _conf.ticks_per_rev) * 2.0 * M_PI * _conf.wheel_radius_right;
        double ds = (d_right + d_left) / 2.0;
        double ds_only_enc = ds;

        // calcolo velocità e accelerazione encoder
        double v_enc_raw = ds / dt;
        _v_enc_smooth = (_conf.alpha_v * v_enc_raw) + ((1.0 - _conf.alpha_v) * _v_enc_smooth); // Low pass filter exponential

        double a_enc_raw = (_v_enc_smooth - _prev_v_enc) / dt;     
        _a_enc_smooth = (_conf.alpha_a * a_enc_raw) + ((1.0 - _conf.alpha_a) * _a_enc_smooth); // Low pass filter exponential

        double a_enc_sma = _filter_enc_a.update(_a_enc_smooth); // Moving average filter
        _prev_v_enc = _v_enc_smooth;

        // manipolazione valori imu per inserire ritardo artificiale simile a encoder
        _imu_accel_smooth_ema1 = (_conf.alpha_v * _current_accel_x) + ((1.0 - _conf.alpha_v) * _imu_accel_smooth_ema1);
        _imu_accel_smooth_ema2 = (_conf.alpha_a * _imu_accel_smooth_ema1) + ((1.0 - _conf.alpha_a) * _imu_accel_smooth_ema2);
        double a_imu_final = _filter_accel.update(_imu_accel_smooth_ema2);

        bool is_slipping = false;

        // rotation encoder
        double d_theta_enc = (d_right - d_left) / _conf.baseline;
        _debug_angle.angle_enc += d_theta_enc;

        _debug_angle.angle_enc = normalize_angle(_debug_angle.angle_enc);


        // Rotation gyro
        double d_theta_gyro = _current_gyro_z * dt;
        _debug_angle.angle_imu += d_theta_gyro;
        _debug_angle.angle_imu = normalize_angle(_debug_angle.angle_imu);

        _debug_slip.angle_ratio = 1.0; //questi valori li utilizzo per visionare il comportamento dei rapporti acc e angolo e come viene aggiornato ds in base a essi
        _debug_slip.accel_ratio = 1.0;
        _debug_slip.ds = ds;

        double turn_threshold = 0.05; // ~3 deg/s
        _filter_enc_theta.update(d_theta_enc);
        _filter_gyro.update(d_theta_gyro);

        double ds_angle = ds;
        double ds_accel = ds;
        double blend_factor = 0.0;
        double ds_fused = ds;

        if(abs(_filter_gyro.current_value()) > 0.001 && abs(_filter_enc_theta.current_value()) > 0.001){ // calcolo rapporto angoli rilevati
              _debug_slip.angle_ratio = abs(_filter_enc_theta.current_value()) / abs(_filter_gyro.current_value());
              if (_debug_slip.angle_ratio < 0.8) _debug_slip.angle_ratio = 0.8;
              if (_debug_slip.angle_ratio > 1.5) _debug_slip.angle_ratio = 1.5;
              ds_angle = ds / _debug_slip.angle_ratio;
        }

        if(abs(a_imu_final) > _conf.min_imu_accel_for_correction){
          _debug_slip.accel_ratio = abs(a_enc_sma) / abs(a_imu_final);
          if(_debug_slip.accel_ratio > 2) _debug_slip.accel_ratio = 2;
          if(_debug_slip.accel_ratio < 0.8) _debug_slip.accel_ratio = 0.8;
          ds_accel = ds / _debug_slip.accel_ratio;
        } 

        if(abs(_current_gyro_z) < turn_threshold) blend_factor = 0.0;// se siamo in movimento rettilineo, fidarsi solamente del rapporto accelerazioni
        else if(abs(_current_gyro_z) >= turn_threshold * 4) blend_factor = 1.0;// se siamo in curva stretta (> 12 deg/s) fidarsi solamente del rapporto angoli
        else{
          blend_factor = (abs(_current_gyro_z) - turn_threshold) / (turn_threshold * 4.0); // condizione intermedia
        }

          
        if(_conf.enable_slip_check && _bias_computed){
            // controllo slippaggio: le condizioni potrebbero essere:
            // uno degli encoder scivola in curva -> differenza angolare alta
            // entrambi gli encoder slittano in rettilineo -> differenza accelerazione alta      
            
            ds_fused = (ds_angle * blend_factor) + (ds_accel * (1.0 - blend_factor));

            if(abs(ds - ds_fused) > (abs(ds) * 0.1)){// se la variazione è superiore al 10% del movimento, consideriamo che stiamo slittando
                ds = ds_fused;
                is_slipping = true;
            }
      }

          
        
        _debug_slip.enc_accel = a_enc_sma;
        _debug_slip.imu_accel = a_imu_final;
        _debug_slip.is_slipping = is_slipping;
        _debug_slip.ds_angle = ds_angle;
        _debug_slip.ds_accel = ds_accel;
        _debug_slip.ds_final = ds_fused;
       

        //Fusione IMU/ENC
        double var_enc = _conf.sigma_enc_rot * _conf.sigma_enc_rot;
        double var_gyro = _conf.sigma_gyro * _conf.sigma_gyro;
        
        double weight_gyro = var_enc / (var_enc + var_gyro);
        double weight_enc = var_gyro / (var_enc + var_gyro);
        
        double d_theta_fused = (d_theta_gyro * weight_gyro) + (d_theta_enc * weight_enc); //CONTROLLO SLITTAMENTO SU ANGOLO

        // Calcolo varianze per update PXX
        //incertezza lineare
        double motion_error_lin = is_slipping ? 0.2 : _conf.sigma_v; // Aumenta incertezza se slittamento
        double sigma_ds = (motion_error_lin * abs(ds)) + (0.01*dt); // incertezza in base al movimento + drift temporale

        // incertezza angolare
        //double combined_sigma = sqrt(pow(_conf.sigma_gyro * weight_gyro, 2) + pow(_conf.sigma_enc_rot * weight_enc, 2));
        double motion_error_ang = _conf.sigma_w;
        double sigma_dtheta = (motion_error_ang * abs(d_theta_fused)) + (0.01*dt); // come caso lineare
        // viene aggiunto (0.01*dt) per evitare varianza nulla in caso di movimento zero. In questo modo aggiorniamo la matrice P aumentando l'incertezza nel tempo, rivelando eventuali errori di deriva.

        ekf_predict(_state, ds, d_theta_fused, sigma_ds, sigma_dtheta);
        ekf_predict(_state_partial, ds, d_theta_fused, sigma_ds, sigma_dtheta);
        
        //Update Stati
        
        // Raw encoder only state - ODOMETRIA PURA
        double avg_theta_enc = _state_enc_only.theta + d_theta_enc / 2.0;
        _state_enc_only.x += ds_only_enc * cos(avg_theta_enc);
        _state_enc_only.y += ds_only_enc * sin(avg_theta_enc);
        _state_enc_only.theta = normalize_angle(_state_enc_only.theta + d_theta_enc);

        
        // Correction
        if(_has_rs_update){
          
          Vector3d Z;
          Z << _rs_x, _rs_y, _ekf_theta_rs;

          Matrix3d R = Matrix3d::Zero();
          R(0, 0) = _conf.sigma_rs_pos * _conf.sigma_rs_pos;
          R(1, 1) = _conf.sigma_rs_pos * _conf.sigma_rs_pos;
          R(2, 2) = _conf.sigma_rs_ang * _conf.sigma_rs_ang;

          ekf_update(_state, Z, R);

          _has_rs_update = false;
        }


        // Error estimation (only for dataset with ground truth)
        if(_bias_computed && _conf.htc && htc_data){
          double dx = _state.x(0) - _htc_x;
          double dy = _state.x(1) - _htc_y;
          err_dist = sqrt(dx*dx + dy*dy); //dist error [m]
          //err_theta = normalize_angle(_state.x(2) - _htc_angle); // angle error [rad]

          _sum_err_dist += err_dist;
          //_sum_err_theta += err_theta;
          _sum_err_dist_sq += err_dist * err_dist;
          //_sum_err_theta_sq += err_theta * err_theta;
          _samples ++;

          double mean_dist = _sum_err_dist / _samples;
          //double mean_theta = _sum_err_theta / _samples;

          rmse_dist = sqrt(_sum_err_dist_sq / _samples);
          //rmse_theta = sqrt(_sum_err_theta_sq / _samples);

          double var_dist = (_sum_err_dist_sq / _samples) - (mean_dist * mean_dist);
          std_dist = sqrt(std::max(0.0, var_dist)); // max to avoid sqrt(-0.00)


          htc_data = false;
        }

        // OUTPUT
        
        // Odometry
        out["debug"]["raw_encoder_only"] = std::vector<double>{_state_enc_only.x, _state_enc_only.y, 0.0};

        // Partial EKF (odom + imu)
        out["debug"]["Odom_corrected"] = std::vector<double>{_state_partial.x(0), _state_partial.x(1), 0.0};

        // Full EKF
        out["pose"]["position"] = std::vector<double>{_state.x(0), _state.x(1), 0.0};
        out["pose"]["orientation"] = _state.x(2);

        // Slip debug
        out["debug"]["accel_enc"] = _debug_slip.enc_accel;
        out["debug"]["accel_imu"] = _debug_slip.imu_accel;
        out["debug"]["is_slipping"] = _debug_slip.is_slipping ? 1.0 : 0.0;
        out["debug"]["angle_ratio"] = _debug_slip.angle_ratio;
        out["debug"]["accel_ratio"] = _debug_slip.accel_ratio;
        out["debug"]["ds"] = _debug_slip.ds;
        out["debug"]["ds_angle"] = _debug_slip.ds_angle;
        out["debug"]["ds_accel"] = _debug_slip.ds_accel;
        out["debug"]["ds_final"] = _debug_slip.ds_final;
        out["debug"]["current_gyro_z"] = _current_gyro_z;
        

        // Angles debug
        out["debug"]["angles"]["theta_enc"] = _debug_angle.angle_enc;
        out["debug"]["angles"]["theta_imu"] = _debug_angle.angle_imu;
        out["debug"]["angles"]["theta_rs"] = _ekf_theta_rs;
        out["debug"]["angles"]["fused_full"] = _state.x(2);
        out["debug"]["angles"]["fused_partial"] = _state_partial.x(2);
        out["debug"]["rs_center"] = std::vector<double>{_rs_x, _rs_y, 0.0};

        //htc position
        out["debug"]["htc_position"] = std::vector<double>{_htc_x, _htc_y, 0.0};
        out["debug"]["angles"]["htc_angle"] = _htc_angle;


        // Error stats
        out["evaluation"]["current_error_dist"] = err_dist;
        out["evaluation"]["rmse_dist"] = rmse_dist;
        out["evaluation"]["std_dist"] = std_dist;

        out["evaluation"]["current_error_theta"] = err_theta;
        out["evaluation"]["rmse_theta"] = rmse_theta;

        if(_samples % 500 == 0 && _samples > 0){
          std::cout << "[METRICS] RMSE Dist: " << rmse_dist << " m "<< std::endl;
        }
        
        if (!_last_agent_id.empty()) out["source_id"] = _last_agent_id;
        out["sim_time"] = _last_timecode;

        return return_type::success;
    }
    

  
  void set_params(void const *params) override {
    // Call the parent class method to set the common parameters 
    // (e.g. agent_id, etc.)
    Filter::set_params(params);
     json p = *(json *)params;

    // provide sensible defaults for the parameters by setting e.g.
    if (p.contains("wheel_radius_left")) _conf.wheel_radius_left = p["wheel_radius_left"];
    if (p.contains("wheel_radius_right")) _conf.wheel_radius_right = p["wheel_radius_right"];
    if (p.contains("baseline")) _conf.baseline = p["baseline"];
    if (p.contains("ticks_per_rev")) _conf.ticks_per_rev = p["ticks_per_rev"];

    if(p.contains("sigma_v")) _conf.sigma_v = p["sigma_v"];
    if(p.contains("sigma_w")) _conf.sigma_w = p["sigma_w"];
    if(p.contains("sigma_acc")) _conf.sigma_acc = p["sigma_acc"];
    if(p.contains("sigma_enc_rot")) _conf.sigma_enc_rot = p["sigma_enc_rot"];
    if(p.contains("sigma_gyro")) _conf.sigma_gyro = p["sigma_gyro"];
    if(p.contains("sigma_rs_pos")) _conf.sigma_rs_pos = p["sigma_rs_pos"];
    if(p.contains("sigma_rs_ang")) _conf.sigma_rs_ang = p["sigma_rs_ang"];
    
    if(p.contains("alpha_a")) _conf.alpha_a = p["alpha_a"];
    if(p.contains("alpha_v")) _conf.alpha_v = p["alpha_v"];
 
    if( p.contains("cam_offset_x")) _conf.cam_offset_x = p["cam_offset_x"];
    if( p.contains("cam_offset_y")) _conf.cam_offset_y = p["cam_offset_y"];

    if( p.contains("rs_global_rotation")) _conf.rs_global_rotation = p["rs_global_rotation"];

    if( p.contains("filter_window_imu")) _conf.filter_window_imu = p["filter_window_imu"];
    if( p.contains("filter_window_enc")) _conf.filter_window_enc = p["filter_window_enc"];

    if (p.contains("min_imu_accel_for_correction")) _conf.min_imu_accel_for_correction = p["min_imu_accel_for_correction"];
    if (p.contains("enable_slip_check")) _conf.enable_slip_check = p["enable_slip_check"];

    if(p.contains("aruco_is_walker_center")) _conf.aruco_is_walker_center = p["aruco_is_walker_center"];

    if(p.contains("calibration_active")) _conf.calibration_active = p["calibration_active"];
    if(p.contains("gyro_scaling")) _conf.gyro_scaling = p["gyro_scaling"];

    if(p.contains("htc")) _conf.htc = p["htc"];

    // then merge the defaults with the actually provided parameters
    // params needs to be cast to json
   // _params.merge_patch(*(json *)params);
    
    _state.x = Vector3d::Zero();
    _state.P = Matrix3d::Identity() * 0.01; // Pic

    _state_partial.x = Vector3d::Zero();
    _state_partial.P = Matrix3d::Identity() * 0.01; //
    
    _state_enc_only = {0,0,0}; // Reset stato raw
    _debug = {0,0};
    _initialized = false;
    _prev_raw_rs_x = -9999.0;
    _prev_raw_rs_y = -9999.0;
    
      
  }
/*
  // Implement this method if you want to provide additional information
  map<string, string> info() override { 
    // return a map of strings with additional information about the plugin
    // it is used to print the information about the plugin when it is loaded
    // by the agent
    
    return {};
    
  };
*/
private:

  // Define the fields that are used to store internal resources
  double _last_input_rs_theta = 0.0;
  double v_enc = 0.0;
 
};


/*
  ____  _             _             _      _
 |  _ \| |_   _  __ _(_)_ __     __| |_ __(_)_   _____ _ __
 | |_) | | | | |/ _` | | '_ \   / _` | '__| \ \ / / _ \ '__|
 |  __/| | |_| | (_| | | | | | | (_| | |  | |\ V /  __/ |
 |_|   |_|\__,_|\__, |_|_| |_|  \__,_|_|  |_| \_/ \___|_|
                |___/
Enable the class as plugin
*/
INSTALL_FILTER_DRIVER(Odometry_filterPlugin, json, json);


/*
                  _       
  _ __ ___   __ _(_)_ __  
 | '_ ` _ \ / _` | | '_ \ 
 | | | | | | (_| | | | | |
 |_| |_| |_|\__,_|_|_| |_|
                          
*/

/*
int main(int argc, char const *argv[])
{
  Odometry_filterPlugin plugin;
  json params;
  json input, output;

  // Set example values to params
  params["test"] = "value";

  // Set the parameters
  plugin.set_params(&params);

  // Set input data
  input["data"] = {
    {"AX", 1},/*
# Odometry Filter Plugin implementing RK2 Integration
*/

// --- MAIN DI TEST (Adattato alla nuova struttura) ---
int main() {
    Odometry_filterPlugin f;
    json params;
    params["baseline"] = 0.5;
    f.set_params(&params);

    json in, out;
    
    // Test Init
    in["encoders"]["left"] = 0;
    in["encoders"]["right"] = 0;
    
    // In MADS 1.4 si chiama PRIMA load_data POI process
    f.load_data(in); 
    f.process(out); 

    // Test Movimento
    //in["encoders"]["left"] = 100;
    //in["encoders"]["right"] = 100;
    
    //f.load_data(in);
    //f.process(out);

   // std::cout << "Pose: " << out.dump(4) << std::endl;
    return 0;
}



